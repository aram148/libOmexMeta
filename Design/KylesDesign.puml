@startuml





/' Objects '/

namespace semsim {
	class Accessor {
		+{static} hasCompartmentWithMetaId(const std::string& metaid, libsbml::Model* m) : bool
		+{static} findCompartment(const std::string& sid, libsbml::Model* m) : libsbml::Compartment*
		+{static} findUnitDefinition(const std::string& sid, libsbml::Model* m) : libsbml::UnitDefinition*
	}
}


namespace semsim {
	class Annotation {
		+{static} stripAnnotations(libsbml::SBMLDocument* d) : void
		+{static} stripAnnotationsFromElement(libsbml::SBase* x) : void
	}
}


namespace semsim {
	abstract class AnnotationBase {
		+~AnnotationBase()
		+{abstract} clone() : AnnotationBase* {query}
		+{abstract} isComposite() : bool {query}
		+{abstract} getRDF(const URI& sbml_base_uri, const std::string& format) : std::string {query}
		+{abstract} humanize() : std::string {query}
		+{abstract} getMetaId() : std::string& {query}
		+{abstract} makeComposite(const PhysicalProperty& prop) : std::unique_ptr<AnnotationBase> {query}
		+{abstract} serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
	}
}


namespace semsim {
	class CHEBI {
		+{static} get(OntologyTerm t) : Resource
	}
}


namespace semsim {
	class CL {
		+{static} get(OntologyTerm t) : Resource
	}
}


namespace semsim {
	class CompositeAnnotation {
		+CompositeAnnotation(const std::string& metaid, const PhysicalProperty& property, const Entity& entity)
		+CompositeAnnotation(const std::string& metaid, PhysicalProperty&& property, Entity&& entity)
		+CompositeAnnotation(const CompositeAnnotation& other)
		+CompositeAnnotation(CompositeAnnotation&& other)
		+CompositeAnnotation(const SingularAnnotation& other, const PhysicalProperty& property)
		+clone() : AnnotationBase* {query}
		+makeComposite(const PhysicalProperty& prop) : AnnotationPtr {query}
		#entity_ : Entity
		+getEntity() : Entity& {query}
		+getEntity() : Entity&
		#property_ : PhysicalProperty
		+isComposite() : bool {query}
		+isEntityEmpty() : bool {query}
		+getRDF(const URI& sbml_base_uri, const std::string& format) : std::string {query}
		+humanize() : std::string {query}
		#metaid_ : std::string
		+getMetaId() : std::string& {query}
		+addTerm(const Relation& relation, const Resource& resource) : void
		#serializePhysicalPropertyToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		+setMetaId(const std::string& metaid) : void
	}
}


namespace semsim {
	class DescriptorTerm {
		+DescriptorTerm(const Relation& relation, const Resource& resource)
		+DescriptorTerm(Relation&& relation, Resource&& resource)
	}
}


namespace semsim {
	class Entity {
		+Entity(const std::string& metaid)
		+Entity(const std::string& metaid, const Resource& definition)
		+Entity(const std::string& metaid, const Resource& definition, const EntityDescriptor& d)
		+Entity(const std::string& metaid, Resource&& definition, EntityDescriptor&& d)
		+Entity(const SingularAnnotation& annotation)
		+Entity(const Entity& other)
		+Entity(Entity&& other)
		+descriptors_() : ) ,
		#descriptors_ : Descriptors
		+getDescriptors() : Descriptors& {query}
		+getDescriptors() : Descriptors&
		+getDescriptor(std::size_t k) : EntityDescriptor& {query}
		+getDescriptor(std::size_t k) : EntityDescriptor&
		+getNumDescriptors() : std::size_t {query}
		+humanize() : std::string {query}
		#humanizeDescriptors() : std::string {query}
		+addDescriptor(const EntityDescriptor& d) : void
		+addDescriptor(EntityDescriptor&& d) : void
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
	}
}


namespace semsim {
	class EntityBase {
		+EntityBase(std::string metaid, const Resource& definition)
		+EntityBase(EntityBase&& other) noexcept: metaid_(std::move(othermetaid_)), definitions_(std::move(otherdefinitions_)), terms_(std::move(otherterms_))
		+EntityBase(std::string metaid, Resource&& definition)
		#definitions_ : Definitions
		+getDefinitions() : Definitions& {query}
		+getDefinitions() : Definitions&
		+getDefinition(std::size_t k) : Resource& {query}
		#terms_ : Terms
		+getURI(const URI& base) : URI {query}
		+isEmpty() : bool {query}
		+matchesDefinition(const Resource& definition) : bool
		+metaid_ : return
		+getNumDefinitions() : std::size_t {query}
		+humanize() : std::string {query}
		#humanizeDefintions() : std::string {query}
		#metaid_ : std::string
		+toString(std::size_t indent) : std::string {query}
		+addDefinition(const Resource& definition) : void
		+addExtraneousTerm(const Term& term) : void
		+addExtraneousTerm(Term&& term) : void
		#serializeDefinition(const Resource& def, const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		#serializeTerm(const Term& term, const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		+setMetaId(const std::string& metaid) : void
	}
}


namespace semsim {
	class EntityDescriptor {
		+EntityDescriptor()
		+EntityDescriptor(const EntityDescriptor& other)
		+EntityDescriptor(EntityDescriptor&& other)
		+EntityDescriptor(std::initializer_list<T> l)
		#terms_ : DescriptorTerms
		+isEmpty() : bool {query}
		+humanize() : std::string {query}
		#humanizeTerms() : std::string {query}
		+addTerm(const DescriptorTerm& t) : void
		+addTerm(DescriptorTerm&& t) : void
		+addTerm(const Relation& relation, const Resource& resource) : void
		#serializeDescriptorTermToRDF(const DescriptorTerm& term, const URI& linked_uri, const URI& term_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		+serializeToRDF(const URI& sbml_base_uri, const std::string& metaid, raptor_world* world, raptor_serializer* serializer) : void {query}
	}
}


namespace semsim {
	class Exception {
		+Exception(const char* message)
		+Exception(std::string message)
		+~Exception()
		+what() : char* {query}
		#msg_ : std::string
	}
}


namespace semsim {
	class GO {
		+{static} get(OntologyTerm t) : Resource
	}
}


namespace semsim {
	class Mediator {
		+Mediator(const std::string& id, Component* component, double multiplier)
		#component_ : Component*
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : URI {query}
		+containsMetaId(const std::string& metaid) : bool {query}
		#multiplier_ : double
		#id_ : std::string
	}
}


namespace semsim {
	class MetaID {
		+{static} modelContainsMetaId(libsbml::Model* m, const std::string& metaid) : bool
		+{static} assignMetaIds(libsbml::Model* m) : void
	}
}


class ModelStrings {
	+ModelStrings()
	+{static} Teusink2000() : std::string
}


namespace semsim {
	class NullPointerException {
		-Exception : using Exception::
	}
}


namespace semsim {
	class OPB {
		+{static} get(OntologyTerm t) : Resource
	}
}


namespace semsim {
	class Process {
		+Process()
		+Process(const SingularAnnotation& annotation)
		+Process(SingularAnnotation&& annotation)
		+Process(const CompositeAnnotation& annotation)
		+Process(CompositeAnnotation&& annotation)
		+Process(const Process& other)
		+Process(Process&& other)
		+clone() : Component* {query}
		#mediators_ : Mediators
		#sinks_ : Sinks
		#sources_ : Sources
		+containsMetaId(const std::string& metaid) : bool {query}
		+isProcess() : bool {query}
		+addMediator(const Mediator& mediator) : void
		+addSink(const Sink& sink) : void
		+addSource(const Source& source) : void
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
	}
}


namespace semsim {
	abstract class Query {
		+~Query()
		+{abstract} run(SemsimModel& model) : QueryResults {query}
	}
}


namespace semsim {
	class QueryResults {
		#refs_ : ComponentRefs
		+begin() : iterator
		+end() : iterator
	}
}


namespace semsim {
	class RDFReader {
		+{static} RaptorTermToURI(raptor_term* t) : URI
		+{static} isMetaId(const std::string& uri) : bool
		+{static} isMetaId(raptor_term* t) : bool
		+{static} RaptorTermToRepr(raptor_term* t) : std::string
		+{static} RaptorURIToString(raptor_uri* u) : std::string
		+{static} extractMetaId(const std::string& uri) : std::string
		+{static} extractMetaId(raptor_term* t) : std::string
		+{static} addTermToAnnotation(AnnotationBase& annotation, const Relation& relation, const Resource& resource) : void
		+{static} addTermToCompositeAnnotation(CompositeAnnotation& annotation, const Relation& relation, const Resource& resource) : void
		+{static} addTermToEntity(EntityBase& entity, const Relation& relation, const Resource& resource) : void
		+{static} addTermToSingularAnnotation(SingularAnnotation& annotation, const Relation& relation, const Resource& resource) : void
		+{static} applyRDFAnnotationsToModel(SemsimModel& model, const std::string& rdf, const std::string& rdf_format) : void
		+{static} process_triple(void* user_data, raptor_statement* triple) : void
	}
}


namespace semsim {
	class SBMLImporter {
		+SBMLImporter(libsbml::SBMLDocument* d)
		+SBMLImporter(const std::string& sbml)
		#extractAnnotation(libsbml::SBase* s) : AnnotationPtr
		#extractAnnotation(libsbml::Species* s) : AnnotationPtr
		#extractAnnotation(libsbml::Compartment* c) : AnnotationPtr
		#extractAnnotation(libsbml::Reaction* r) : AnnotationPtr
		#extractAnnotation(libsbml::Parameter* p) : AnnotationPtr
		#getComponentFor(libsbml::SBase* s) : Component*
		#extractCompositeAnnotation(libsbml::Species* s) : CompositeAnnotation
		#extractSpeciesEntity(libsbml::Species* s) : Entity
		#extractSpeciesEntityDescriptor(libsbml::Species* s) : EntityDescriptor
		+{static} getRelationFromSBMLQual(libsbml::BiolQualifierType_t q) : Relation&
		#getResourceFor(libsbml::SBase* s) : Resource
		#importedSBMLModel : SemSimSBMLModel
		+getSBMLModel() : SemSimSBMLModel&
		+getSemSimSBMLModel() : SemSimSBMLModel& {query}
		#{static} extractSingularAnnotation(libsbml::SBase* s) : SingularAnnotation
		#{static} extractSingularAnnotation(libsbml::Parameter* p) : SingularAnnotation
		#sbmlModel : libsbml::Model*
		#{static} makeUniqueMetaId(const SemsimModel& model, const std::string& base) : std::string
		#assignParticipants(Process& process, libsbml::Reaction* r) : void
		#{static} populateDefinitionsAndTerms(libsbml::SBase* s, EntityBase& e) : void
		#{static} populateSBOTerm(libsbml::SBase* s, EntityBase& e) : void
	}
}


namespace semsim {
	class SemSimSBMLModel {
		+SemSimSBMLModel(libsbml::SBMLDocument* d)
		+SemSimSBMLModel(SemSimSBMLModel&& other) noexcept: SemsimModel(std::move(other)), element_map_(std::move(otherelement_map_)), element_id_map_(std::move(otherelement_id_map_)), d_(otherd_)
		+getComponent(libsbml::SBase* s) : Component* {query}
		+getComponent(libsbml::SBase* s) : Component*
		+getComponentForId(const std::string& id) : Component* {query}
		+getComponentForId(const std::string& id) : Component*
		+getProcess(libsbml::SBase* s) : Process*
		#element_map_ : SEMSIM_TR1_NAMESPACE_QUAL unordered_map<libsbml::SBase*, Component*>
		#element_id_map_ : SEMSIM_TR1_NAMESPACE_QUAL unordered_map<std::string, Component*>
		+hasComponent(const std::string id) : bool {query}
		+hasComponent(libsbml::SBase* s) : bool {query}
		+hasProcess(libsbml::SBase* s) : bool {query}
		#d_ : libsbml::SBMLDocument*
		+encodeXML() : std::string {query}
		+getFormat() : std::string {query}
		+getRDF(const URI& sbml_base_uri, const std::string& format) : std::string {query}
		+getRDF(const std::string& sbml_base_uri, const std::string& format) : std::string {query}
		+setComponentAnnotation(libsbml::SBase* s, const AnnotationBase& annotation) : void
		+setComponentAnnotation(libsbml::SBase* s, const AnnotationPtr& annotation) : void
		+setComponentAnnotation(libsbml::SBase* s, AnnotationPtr&& annotation) : void
	}
}


namespace semsim {
	class SBMLSpecies {
		+{static} GetSpeciesPhysicalProperty(libsbml::Species* s, libsbml::Model* m) : PhysicalProperty
		+{static} SubstanceUnitsAreConc(libsbml::Species* s, libsbml::Model* m) : bool
		+{static} UnitDefIsConc(libsbml::UnitDefinition* ud) : bool
	}
}


namespace semsim {
	class SBO {
		+{static} get(OntologyTerm t) : Resource
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+IdentityCondition(Resource resource)
		#resource_ : Resource
		+matchEntity(const EntityBase& entity) : bool {query}
		+matches(const Component& component) : bool {query}
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+SelectQuery(ConditionPtr&& where)
		#where_ : ConditionPtr
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+~Participant()
	}
}


namespace semsim {
	abstract class SEMSIM_PUBLIC {
		+~Condition()
		+{abstract} matches(const Component& component) : bool
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+PhysicalProperty(const Resource& resource)
		+PhysicalProperty(Resource&& resource)
		+PhysicalProperty(const std::string& resource)
		+PhysicalProperty(std::string&& resource)
		#resource_ : Resource
		+getResource() : Resource& {query}
		+getResource() : Resource&
		+humanize() : std::string {query}
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+Term(const Relation& relation, const Resource& resource)
		+Term(Relation&& relation, Resource&& resource)
		+Term(const Relation& relation, const double value)
		#relation_ : Relation
		+getRelation() : Relation& {query}
		#resource_ : Resource
		+getResource() : Resource& {query}
		+isValue() : bool {query}
		#is_value_ : bool
		+getValue() : double {query}
		#value_ : double
		+toString() : std::string {query}
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+RasqalQueryResult(rasqal_query_results* results)
		+~RasqalQueryResult()
		#results_ : rasqal_query_results*
		+toRDFString(const std::string& format) : std::string
		+toString() : std::string
		+asList() : std::vector<std::vector<std::string> >
		#toRaptorGraph(raptor_world* world, raptor_serializer* serializer) : void
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+Resource(const URI& uri)
		+Resource(URI&& uri)
		+Resource(Component* element)
		#element_ : Component*
		+getURI(const URI& base) : URI {query}
		#uri_ : URI
		+isLocal() : bool {query}
		+operator==(const Resource& other) : bool {query}
		+humanize() : std::string {query}
		+toString() : std::string {query}
	}
}


namespace semsim {
	abstract class SEMSIM_PUBLIC {
		+SemsimModel()
		+SemsimModel(const SemsimModel& other)
		+SemsimModel(SemsimModel&& other) noexcept: components_(std::move(othercomponents_))
		+~SemsimModel()
		+findComponentWithMetaId(const std::string& metaid) : Component&
		+findComponentWithMetaId(const std::string& metaid) : Component& {query}
		+addComponent(const Component& component) : Component*
		+addComponent(Component&& component) : Component*
		+getComponents() : Components& {query}
		+getComponents() : Components&
		+addComponent(const Process& component) : Process*
		+addComponent(Process&& component) : Process*
		+containsMetaId(const std::string& metaid) : bool {query}
		+hasComponentWithMetaId(const std::string& metaid) : bool {query}
		#components_ : semsim::Components
		+getNumComponents() : std::size_t {query}
		+{abstract} encodeXML() : std::string {query}
		+{abstract} getFormat() : std::string {query}
		+{abstract} getRDF(const URI& sbml_base_uri, const std::string& format) : std::string {query}
		+humanize() : std::string {query}
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+Relation(const URI& uri)
		+Relation(URI&& uri)
		#uri_ : URI
		+getURI() : URI& {query}
		+operator==(const Relation& other) : bool {query}
		+humanize() : std::string {query}
		+toString() : std::string {query}
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+RasqalQuery(const std::string& rdf, const std::string& format, bool is_file)
		+~RasqalQuery()
		+run(const std::string& query) : RasqalQueryResult
		#raptor_iostr_ : raptor_iostream*
		#base_uri_ : raptor_uri*
		#uri_ : raptor_uri*
		#raptor_world_ : raptor_world*
		#dg_ : rasqal_data_graph*
		#query_ : rasqal_query*
		#rasqal_world_ : rasqal_world*
		#rdf_ : std::string
		#uri_string_ : unsigned char*
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+{static} resolve(const std::string& root, unsigned int t, int n_digits) : Resource
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+{static} encodes : const static Relation
		+{static} hasPart : const static Relation
		+{static} hasProperty : const static Relation
		+{static} hasTaxon : const static Relation
		+{static} hasVersion : const static Relation
		+{static} is : const static Relation
		+{static} isDescribedBy : const static Relation
		+{static} isEncodedBy : const static Relation
		+{static} isHomologTo : const static Relation
		+{static} isPartOf : const static Relation
		+{static} isPropertyOf : const static Relation
		+{static} isVersionOf : const static Relation
		+{static} occursIn : const static Relation
		+{static} root : const static std::string
		+{static} humanizeQualifier(const Relation& q) : std::string
	}
}


namespace semsim {
	class SEMSIM_PUBLIC {
		+Component()
		+Component(const SingularAnnotation& annotation)
		+Component(SingularAnnotation&& annotation)
		+Component(const CompositeAnnotation& annotation)
		+Component(CompositeAnnotation&& annotation)
		+Component(const Component& other)
		+Component(Component&& other) noexcept: annotation_(std::move(otherannotation_))
		+~Component()
		+getAnnotation() : AnnotationBase& {query}
		+getAnnotation() : AnnotationBase&
		#annotation_ : AnnotationPtr
		+clone() : Component* {query}
		+getCompositeAnnotation() : CompositeAnnotation& {query}
		+getCompositeAnnotation() : CompositeAnnotation&
		+getURI(const URI& base) : URI {query}
		+containsMetaId(const std::string& metaid) : bool {query}
		+hasAnnotation() : bool {query}
		+hasCompositeAnnotation() : bool {query}
		+hasMetaId() : bool {query}
		+hasSingularAnnotation() : bool {query}
		+isProcess() : bool {query}
		+getRDF(const URI& sbml_base_uri, const std::string& format) : std::string {query}
		+humanize() : std::string {query}
		#metaid_ : std::string
		+getMetaId() : std::string& {query}
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
		+setAnnotation(AnnotationBase* annotation) : void
		+setAnnotation(const AnnotationBase& annotation) : void
		+setAnnotation(AnnotationPtr&& annotation) : void
		+setMetaId(const std::string& metaid) : void
	}
}


namespace semsim {
	class SemSimObject {
		+SemSimObject(SemSimTypes type)
		#semsimtype : SemSimTypes
		+hasDescription() : bool {query}
		+hasMetadataID() : bool {query}
		+hasName() : bool {query}
		#description : std::string
		#metadataID : std::string
		#name : std::string
		+getDescription() : std::string& {query}
		+getMetadataID() : std::string& {query}
		+getName() : std::string& {query}
		+copyDescription(const SemSimObject& other) : void
		+setDescription(const std::string& description) : void
		+setMetadataID(const std::string& metadataID) : void
		+setName(const std::string& name) : void
	}
}


namespace semsim {
	class SingularAnnotation {
		+SingularAnnotation(const std::string& metaid, const Resource& definition)
		+SingularAnnotation(const std::string& metaid)
		+SingularAnnotation(const std::string& metaid, Resource&& definition)
		+SingularAnnotation(const SingularAnnotation& other)
		+SingularAnnotation(SingularAnnotation&& other)
		+clone() : AnnotationBase* {query}
		+makeComposite(const PhysicalProperty& prop) : AnnotationPtr {query}
		+getURI(const URI& base) : URI {query}
		+isComposite() : bool {query}
		+getRDF(const URI& sbml_base_uri, const std::string& format) : std::string {query}
		+humanize() : std::string {query}
		+getMetaId() : std::string& {query}
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : void {query}
	}
}


namespace semsim {
	class Sink {
		+Sink(const std::string& id, Component* component, double multiplier)
		#component_ : Component*
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : URI {query}
		+containsMetaId(const std::string& metaid) : bool {query}
		#multiplier_ : double
		#id_ : std::string
	}
}


namespace semsim {
	class Source {
		+Source(const std::string& id, Component* component, double multiplier)
		#component_ : Component*
		+serializeToRDF(const URI& sbml_base_uri, raptor_world* world, raptor_serializer* serializer) : URI {query}
		+containsMetaId(const std::string& metaid) : bool {query}
		#multiplier_ : double
		#id_ : std::string
	}
}


namespace semsim {
	class URI {
		+URI()
		+URI(const std::string& uri)
		+URI(const char* uri)
		+URI(std::string&& uri)
		+appendToFrag(const std::string& suffix) : URI {query}
		+withFrag(const std::string& suffix) : URI {query}
		+operator==(const URI& other) : bool {query}
		+encode() : std::string {query}
		#encoded_uri_ : std::string
		+toString() : std::string {query}
	}
}


namespace semsim {
	class semsim {
		+{static} hasMediatorParticipant : const static Relation
		+{static} hasMultiplier : const static Relation
		+{static} hasPhysicalEntityReference : const static Relation
		+{static} hasSBOTerm : const static Relation
		+{static} hasSinkParticipant : const static Relation
		+{static} hasSourceParticipant : const static Relation
		+{static} hasValue : const static Relation
		+{static} root : const static std::string
	}
}





/' Inheritance relationships '/

namespace semsim {
	AnnotationBase <|-- CompositeAnnotation
}


namespace semsim {
	AnnotationBase <|-- SingularAnnotation
}


namespace semsim {
	EntityBase <|-- Entity
}


namespace semsim {
	EntityBase <|-- SingularAnnotation
}


namespace semsim {
	Exception <|-- NullPointerException
}





/' Aggregation relationships '/

namespace semsim {
	CompositeAnnotation *-- Entity
}


namespace semsim {
	NullPointerException *-- Exception
}


namespace semsim {
	SBMLImporter *-- SemSimSBMLModel
}





@enduml
