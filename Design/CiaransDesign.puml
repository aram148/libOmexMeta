@startuml
skinparam monochrome true



'Base class for all annotations
class Annotation {
    + serialize() : std::string
    + iscomposite() : bool
}
'todo Conceptually, could we use an isa relationshop between singular annotation and Triple?

class SingularAnnotation {
    + triple : Triple
    + serialize() :std::string
}
note top of SingularAnnotation
    Should I have a
    RDF interface for
    methods such as
    serialize?
end note

note left of SingularAnnotation
    Q) Can we use an
    "is-a" relationship
    between Triple and
    SingularAnnotation?
    i.e inheritance not
    composition.
end note
'Not sure what type the physicalEntity / physicalProperty should have.
'Not sure what the physicalEntity should be called.
'From section 2.27 of omex metadata spec: physical entity, process, force or dependency that bears the physical property.
class CompositeAnnotation {
    + physicalProperty : PhysicalProperty
    + physicalEntity : Entity*
    + serialize() :std::string
}

SingularAnnotation --|> Annotation
CompositeAnnotation --|> Annotation
Triple <-- SingularAnnotation

class Uri {
    - uri_str : std::string
    + parse() : void
}
note right of Uri
    This class is overkill now.
    May be better to reimplement
    or remove.
end note
class Subject {
    + metaId : Uri
}

interface Predicate {
    + cv : ControlledVocabulary*
}
class ControlledVocabulary <<BaseClass>> {
    + namespace : std::string
    + root      : std::string
    + qualifier : std::string
    + getUri() : Uri
}
note top of ControlledVocabulary
    Rename to Term???
end note
ControlledVocabulary <-- Predicate
Uri <-- ControlledVocabulary

class BiomodelsQualifier {}
class OPB {}
class CHEBI {}
ControlledVocabulary <|-- BiomodelsQualifier
ControlledVocabulary <|-- OPB
ControlledVocabulary <|-- CHEBI


class Resource {
    - identifiers_base: std::string
    - namespace : std::string
    - identifier : std::string
}
note right of Resource
    This class implements
    a Resource as a web
    resource resolvable by
    identifiers.org but
    not a resource from a
    literal. However,
    might be better to
    just use a string for
    literal?
end note
class ResourceUrl {}

class ResourceLiteral {}

Resource <|-- ResourceUrl
Resource <|-- ResourceLiteral

note top of Resource
    Object part of rdf.
end note


class Triple {
    + subject : Subject
    + predicate : Predicate
    + resource : Resource*
}

Subject <-- Triple
Predicate <-- Triple
Resource <-- Triple


Uri <-- Subject

class PhysicalProperty {
    + triple : Triple*
}
Triple <-- PhysicalProperty

interface Entity {
    + triple : Triple
}
Triple <-- Entity

class PhysicalEntity {}
class PhysicalProcess {}
class PhysicalForce {}
class PhysicalDependency {}

Entity <|-- PhysicalEntity
Entity <|-- PhysicalProcess
Entity <|-- PhysicalForce
Entity <|-- PhysicalDependency

Entity <-- CompositeAnnotation
PhysicalProperty <-- CompositeAnnotation


class ListOfAnnotations {
    + annotations : std::unique_ptr<Annotation>
    + fromSBML() : static ListOfAnnotations
    + fromCellML() : static ListOfAnnotations
    + toSBML() :    void
    + toCellML() :  void
}

Annotation <-- ListOfAnnotations





@enduml