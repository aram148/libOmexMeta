@startuml
skinparam backgroundcolor white

skinparam class {
	BackgroundColor FFF0DE
	ArrowColor grey
	BorderColor grey
	BackgroundColor<<NotYetImplemented>> FFA436
}



class Uri {
    - uri_str : std::string
    + parse() : void
}
note right of Uri
    This class is overkill now.
    May be better to reimplement
    or remove.
end note
class Subject {
    + metaId : Uri
}

interface Predicate {
    + cv : ControlledVocabulary*
}
class ControlledVocabulary <<BaseClass>> {
    + namespace : std::string
    + root      : std::string
    + qualifier : std::string
    + getUri() : Uri
}
note top of ControlledVocabulary
    Rename to Term???
end note
ControlledVocabulary <-- Predicate
Uri <-- ControlledVocabulary

class BiomodelsQualifier {}
class OPB {}
class CHEBI {}
ControlledVocabulary <|-- BiomodelsQualifier
ControlledVocabulary <|-- OPB
ControlledVocabulary <|-- CHEBI


class Resource {
    - identifiers_base: std::string
    - namespace : std::string
    - identifier : std::string
}
note right of Resource
    This class implements
    a Resource as a web
    resource resolvable by
    identifiers.org but
    not a resource from a
    literal. However,
    might be better to
    just use a string for
    literal?
end note
class ResourceUrl {}

class ResourceLiteral <<NotYetImplemented>>{}

Resource <|-- ResourceUrl
Resource <|-- ResourceLiteral

note top of Resource
    Object part of rdf.
end note


class Triple {
    + subject : Subject
    + predicate : Predicate
    + resource : Resource*
    + serialize() : std::string
}

Subject <-- Triple
Predicate <-- Triple
Resource <-- Triple

class ListOfTriples <<NotYetImplemented>>{
    + triples : std::vector<Triple*>
    + serialize() : std::string
}

interface IRDF {
    + serialize() : std::string
}

IRDF <|-- Triple
IRDF <|-- ListOfTriples
IRDF <|-- SingularAnnotation
ListOfTriples --> Triple

Uri <-- Subject

class PhysicalProperty <<NotYetImplemented>>{
    + triple : Triple*
}
Triple <-- PhysicalProperty

interface Entity<<NotYetImplemented>> {
    + triple : Triple
}
Triple <-- Entity

class PhysicalEntity <<NotYetImplemented>>{}
class PhysicalProcess<<NotYetImplemented>> {}
class PhysicalForce <<NotYetImplemented>>{}
class PhysicalDependency <<NotYetImplemented>>{}

Entity <|-- PhysicalEntity
Entity <|-- PhysicalProcess
Entity <|-- PhysicalForce
Entity <|-- PhysicalDependency


'Base class for all annotations
class Annotation<<NotYetImplemented>> {
    + serialize() : std::string
    + iscomposite() : bool
}
note right of Annotation
    Base class for annotations.
    Primarily for polymorphism.
end note
'todo Conceptually, could we use an isa relationshop between singular annotation and Triple?

class SingularAnnotation <<NotYetImplemented>>{
    + triple : Triple
    + serialize() :std::string
}
note top of SingularAnnotation
    Should I have a
    RDF interface for
    methods such as
    serialize?
end note

note left of SingularAnnotation
    Q) Can we use an
    "is-a" relationship
    between Triple and
    SingularAnnotation?
    i.e inheritance not
    composition.
end note
'Not sure what type the physicalEntity / physicalProperty should have.
'Not sure what the physicalEntity should be called.
'From section 2.27 of omex metadata spec: physical entity, process, force or dependency that bears the physical property.
class CompositeAnnotation<<NotYetImplemented>> {
    + physicalProperty : PhysicalProperty
    + physicalEntity : Entity*
    + serialize() :std::string
}

SingularAnnotation --|> Annotation
CompositeAnnotation --|> Annotation
Triple <-- SingularAnnotation

Entity <-- CompositeAnnotation
PhysicalProperty <-- CompositeAnnotation


class ListOfAnnotations <<NotYetImplemented>>{
    + annotations : std::unique_ptr<Annotation>
    + fromSBML() : static ListOfAnnotations
    + fromCellML() : static ListOfAnnotations
    + toSBML() :    void
    + toCellML() :  void
}

Annotation <-- ListOfAnnotations



@enduml